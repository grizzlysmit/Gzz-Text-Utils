.pc
.TH Utils.rakumod 1 2024-01-22
.SS Table of Contents
.IP \(bu 2m
NAME [#name]
.IP \(bu 2m
AUTHOR [#author]
.IP \(bu 2m
VERSION [#version]
.IP \(bu 2m
TITLE [#title]
.IP \(bu 2m
SUBTITLE [#subtitle]
.IP \(bu 2m
COPYRIGHT [#copyright]
.IP \(bu 2m
Introduction [#introduction]
.RS 2n
.IP \(bu 2m
Motivations [#motivations]
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Update [#update]
.RE
.RE
.IP \(bu 2m
Exceptions [#exceptions]
.RS 2n
.IP \(bu 2m
BadArg [#badarg]
.RE
.RS 2n
.IP \(bu 2m
ArgParityMissMatch [#argparitymissmatch]
.RE
.RS 2n
.IP \(bu 2m
FormatSpecError [#formatspecerror]
.RE
.IP \(bu 2m
UnhighlightBase & UnhighlightBaseActions and Unhighlight & UnhighlightActions [#unhighlightbase--unhighlightbaseactions-and-unhighlight--unhighlightactions]
.IP \(bu 2m
The Functions Provided [#the-functions-provided]
.RS 2n
.IP \(bu 2m
Here are 4 functions provided to \fBcentre\fR, \fBleft\fR and \fBright\fR justify text even when it is ANSI formatted [#here-are-4-functions-provided-to-centre-left-and-right-justify-text-even-when-it-is-ansi-formatted]
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
centre(…) [#centre]
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
left(…) [#left]
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
right(…) [#right]
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
crop\-field(…) [#crop-field]
.RE
.RE
.RE
.RS 2n
.IP \(bu 2m
Sprintf [#sprintf]
.RE
.RS 2n
.IP \(bu 2m
Printf [#printf]
.RE
.RS 2n
.IP \(bu 2m
MultiT [#multit]
.RE
.RS 2n
.IP \(bu 2m
menu(…) [#menu]
.RE
.RS 2n
.IP \(bu 2m
input\-menu(…) [#input-menu]
.RE
.RS 2n
.IP \(bu 2m
dropdown(…) [#dropdown]
.RE
.RS 2n
.IP \(bu 2m
lead\-dots(…) [#lead-dots]
.RE
.RS 2n
.IP \(bu 2m
trailing\-dots(…) [#trailing-dots]
.RE
.RS 2n
.IP \(bu 2m
dots(…) [#dots]
.RE
.SH "NAME"
Gzz::Text::Utils 
.SH "AUTHOR"
Francis Grizzly Smit (grizzly@smit\&.id\&.au)
.SH "VERSION"
v0\&.1\&.23
.SH "TITLE"
Gzz::Text::Utils
.SH "SUBTITLE"
A Raku module to provide text formatting services to Raku programs\&.
.SH "COPYRIGHT"
LGPL V3\&.0+ LICENSE [https://github.com/grizzlysmit/Gzz-Text-Utils/blob/main/LICENSE]
.SH Introduction

A Raku module to provide text formatting services to Raku programs\&.

Including a sprintf front\-end Sprintf that copes better with Ansi highlighted text and implements \fB%U\fR and does octal as \fB0o123\fR or \fB0O123\fR if you choose \fB%O\fR as I hate ambiguity like \fB0123\fR is it an int with leading zeros or an octal number\&. Also there is \fB%N\fR for a new line and \fB%T\fR for a tab helpful when you want to use single quotes to stop the \fB<num> $\fR specs needing back slashes\&.

And a \fBprintf\fR alike \fBPrintf\fR\&.

Also it does centring and there is a \fBmax\-width\fR field in the \fB%\fR spec i\&.e\&. \fB%*\&.*\&.*E\fR, and more\&.

Top of Document [#table-of-contents]
.SS Motivations

When you embed formatting information into your text such as \fBbold\fR, \fIitalics\fR, etc \&.\&.\&. and \fBcolours\fR standard text formatting will not work e\&.g\&. printf, sprintf etc also those functions don't do centring\&.

Another important thing to note is that even these functions will fail if you include such formatting in the \fBtext\fR field unless you supply a copy of the text with out the formatting characters in it in the \fB:ref\fR field i\&.e\&. \fBleft($formatted\-text, $width, :ref($unformatted\-text))\fR or \fBtext($formatted\-text, $width, :$ref)\fR if the reference text is in a variable called \fB$ref\fR or you can write it as \fBleft($formatted\-text, $width, ref => $unformatted\-text)\fR

Top of Document [#able-of-contents]
.SS Update

Fixed the proto type of \fBleft\fR etc is now 

.RS 4m
.EX
sub left(Str:D $text, Int:D $width is copy, Str:D $fill = ' ',
            :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) = &left\-global\-number\-of\-chars,
               Str:D :$ref = strip\-ansi($text), Int:D
                                :$max\-width = 0, Str:D :$ellipsis = '' \-\-> Str) is export 

.EE
.RE
.P
Where \fBsub strip\-ansi(Str:D $text \-\-> Str:D) is export\fR is my new function for striping out ANSI escape sequences so we don't need to supply \fB:$ref\fR unless it contains codes that \fBsub strip\-ansi(Str:D $text \-\-> Str:D) is export\fR cannot strip out, if so I would like to know so I can update it to cope with these new codes\&.

Top of Document [#table-of-contents]
.SH Exceptions
.SS BadArg

.RS 4m
.EX
class BadArg is Exception is export


.EE
.RE
.P
BadArg is a exception type that Sprintf will throw in case of badly specified arguments\&.

Top of Document [#table-of-contents]
.SS ArgParityMissMatch

.RS 4m
.EX
class ArgParityMissMatch is Exception is export


.EE
.RE
.P
ArgParityMissMatch is an exception class that Sprintf throws if the number of arguments does not match what the number the format string says there should be\&.

\fBNB: if you use \fInum$\fR argument specs these will not count as they grab from the args add hoc, \fI*\fR width and precision spec however do count as they consume argument\&.\fR
Top of Document [#table-of-contents]
.SS FormatSpecError

.RS 4m
.EX
class FormatSpecError is Exception is export


.EE
.RE
.P
FormatSpecError is an exception class that Format (used by Sprintf) throws if there is an error in the Format specification (i\&.e\&. \fB%n\fR instead of \fB%N\fR as \fB%n\fR is already taken, the same with using \fB%t\fR instead of \fB%T\fR)\&.

Or anything else wrong with the Format specifier\&.

\fBNB: \fI%N\fR introduces a \fI\n\fR character and \fI%T\fR a tab (i\&.e\&. \fI\t\fR)\&.\fR
Top of Document [#table-of-contents]
.SH Format and FormatActions

Format & FormatActions are a grammar and Actions pair that parse out the \fB%\fR spec and normal text chunks of a format string\&.

For use by Sprintf a sprintf alternative that copes with ANSI highlighted text\&.
Top of Document [#table-of-contents]
.SH UnhighlightBase & UnhighlightBaseActions and Unhighlight & UnhighlightActions

\fBUnhighlightBase\fR & \fBUnhighlightBaseActions\fR are a grammar & role pair that does the work required to to parse apart ansi highlighted text into ANSI highlighted and plain text\&. 

\fBUnhighlight\fR & \fBUnhighlightActions\fR are a grammar & class pair which provide a simple TOP for applying an application of \fBUnhighlightBase\fR & \fBUnhighlightBaseActions\fR for use by \fBsub strip\-ansi(Str:D $text \-\- Str:D) is export\fR> to strip out the plain text from a ANSI formatted string
Top of Document [#table-of-contents]
.SH The Functions Provided
.IP \(bu 2m
strip\-ansi
.IP

.RS 4m
.EX
sub strip\-ansi(Str:D $text \-\-> Str:D) is export


.EE
.RE
.IP
Strips out all the ANSI escapes, at the moment just those provided by the \fBTerminal::ANSI\fR or \fBTerminal::ANSI::OO\fR modules both available as \fBTerminal::ANSI\fR from zef etc I am not sure how exhaustive that is, but I will implement any more escapes as I become aware of them\&.
.IP \(bu 2m
hwcswidth
.IP

.RS 4m
.EX
sub hwcswidth(Str:D $text \-\-> Int:D) is export


.EE
.RE
.IP
Same as \fBwcswidth\fR but it copes with ANSI escape sequences unlike \fBwcswidth\fR\&.
.RS 2n
.IP \(bu 2m
The secret sauce is that it is defined as:
.IP

.RS 4m
.EX
sub hwcswidth(Str:D $text \-\-> Int:D) is export {
    return wcswidth(strip\-ansi($text));
} #  sub hwcswidth(Str:D $text \-\-> Int:D) is export #



.EE
.RE
.RE
Top of Document [#table-of-contents]
.SS Here are 4 functions provided to \fBcentre\fR, \fBleft\fR and \fBright\fR justify text even when it is ANSI formatted\&.
.SS centre
.IP \(bu 2m
⋄
.RS 2n
.IP \(bu 2m
Centring text in a field\&.
.IP

.RS 4m
.EX
sub centre(Str:D $text,
           Int:D $width is copy,
           Str:D $fill = ' ',
           :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) =
                               &centre\-global\-number\-of\-chars,
           Str:D :$ref = strip\-ansi($text),
           Int:D :$max\-width = 0,
           Str:D :$ellipsis = '' \-\-> Str) is export {


.EE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
Centres the text \fB$text\fR in a field of width \fB$width\fR padding either side with \fB$fill\fR
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBWhere:\fR
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$fill\fR is the fill char by default \fB$fill\fR is set to a single white space\&.
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
If it requires an odd number of padding then the right hand side will get one more char/codepoint\&.
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB&number\-of\-chars\fR takes a function which takes 2 \fBInt:D\fR's and returns a \fBBool:D\fR\&.
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
By default this is equal to the closure \fBcentre\-global\-number\-of\-chars\fR which looks like:
.IP

.RS 4m
.EX
our $centre\-total\-number\-of\-chars is export = 0;
our $centre\-total\-number\-of\-visible\-chars
                                  is export = 0;

sub centre\-global\-number\-of\-chars(
      Int:D $number\-of\-chars,
      Int:D $number\-of\-visible\-chars \-\-> Bool:D) {
    $centre\-total\-number\-of\-chars         =
                         $number\-of\-chars;
    $centre\-total\-number\-of\-visible\-chars =
                         $number\-of\-visible\-chars;
    return True;
}


.EE
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
Which is a closure around the variables: \fB$centre\-total\-number\-of\-chars\fR and \fB$centre\-total\-number\-of\-visible\-chars\fR, these are global \fBour\fR variables that \fBGzz::Text::Utils\fR exports\&. But you can just use \fBmy\fR variables from with a scope, just as well\&. And make the \fBsub\fR local to the same scope\&.
.IP
Top of Document [#table-of-contents]
.IP
i\&.e\&.
.IP

.RS 4m
.EX
sub Sprintf(Str:D $format\-str,
                :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) = &Sprintf\-global\-number\-of\-chars,
                                                        Str:D :$ellipsis = '', *@args \-\-> Str) is export {
    \&.\&.\&.
    \&.\&.\&.
    \&.\&.\&.
    my Int:D $total\-number\-of\-chars = 0;
    my Int:D $total\-number\-of\-visible\-chars = 0;
    sub internal\-number\-of\-chars(Int:D $number\-of\-chars, Int:D $number\-of\-visible\-chars \-\-> Bool:D) {
        $total\-number\-of\-chars += $number\-of\-chars;
        $total\-number\-of\-visible\-chars += $number\-of\-visible\-chars;
        return True;
    } # sub internal\-number\-of\-chars(Int:D $number\-of\-chars, Int:D $number\-of\-visible\-chars \-\-> Bool:D) #
    \&.\&.\&.
    \&.\&.\&.
    \&.\&.\&.
    for @format\-str \-> %elt {
        my Str:D $type = %elt«type»;
        if $type eq 'literal' {
            my Str:D $lit = %elt«val»;
            $total\-number\-of\-chars += $lit\&.chars;
            $total\-number\-of\-visible\-chars += strip\-ansi($lit)\&.chars;
            $result ~= $lit;
        } elsif $type eq 'fmt\-spec' {
            \&.\&.\&.
            \&.\&.\&.
            \&.\&.\&.
            given $spec\-char {
                when 'c' {
                             $arg \&.=Str;
                             $ref \&.=Str;
                             BadArg\&.new(:msg("arg should be one codepoint: {$arg\&.codes} found"))\&.throw if $arg\&.codes != 1;
                             $max\-width = max($max\-width, $precision, 0) if $max\-width > 0; #`« should not really have a both for this
                                                                                                so munge together\&.
                                                                                                Traditionally sprintf etc treat precision
                                                                                                as max\-width for strings\&. »
                             if $padding eq '' {
                                 if $justify eq '' {
                                     $result ~=  right($arg, $width, :$ref, :number\-of\-chars(&internal\-number\-of\-chars), :$max\-width);
                                 } elsif $justify eq '\-' {
                                     $result ~=  left($arg, $width, :$ref, :number\-of\-chars(&internal\-number\-of\-chars), :$max\-width);
                                 } elsif $justify eq '^' {
                                     $result ~=  centre($arg, $width, :$ref, :number\-of\-chars(&internal\-number\-of\-chars), :$max\-width);
                                 }
                             } else {
                                 if $justify eq '' {
                                     $result ~=  right($arg, $width, $padding, :$ref, :number\-of\-chars(&internal\-number\-of\-chars), :$max\-width);
                                 } elsif $justify eq '\-' {
                                     $result ~=  left($arg, $width, $padding, :$ref, :number\-of\-chars(&internal\-number\-of\-chars), :$max\-width);
                                 } elsif $justify eq '^' {
                                     $result ~=  centre($arg, $width, $padding, :$ref, :number\-of\-chars(&internal\-number\-of\-chars), :$max\-width);
                                 }
                             }
                         }
                when 's' {
                            \&.\&.\&.
                            \&.\&.\&.
                            \&.\&.\&.
        \&.\&.\&.
        \&.\&.\&.
        \&.\&.\&.
    \&.\&.\&.
    \&.\&.\&.
    \&.\&.\&.
    return $result;
    KEEP {
        &number\-of\-chars($total\-number\-of\-chars, $total\-number\-of\-visible\-chars);
    }
} #`««« sub Sprintf(Str:D $format\-str,
                :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) = &Sprintf\-global\-number\-of\-chars,
                                                        Str:D :$ellipsis = '', *@args \-\-> Str) is export »»»


.EE
.RE
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
The parameter \fB:$ref\fR is by default set to the value of \fBstrip\-ansi($text)\fR
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
This is used to obtain the length of the of the text using \fB\fIwcswidth(Str)\fR\fR from module \fB"Terminal::WCWidth"\fR which is used to obtain the width the text if printed on the current terminal:
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBNB: wcswidth will return \-1 if you pass it text with colours etc embedded in them\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB"Terminal::WCWidth"\fR is witten by \fBbluebear94\fR github:bluebear94 [https://raku.land/github:bluebear94] get it with \fBzef\fR or whatever
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB:$max\-width\fR sets the maximum width of the field but if set to \fB0\fR (The default), will effectively be infinite (∞)\&.
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB:$ellipsis\fR is used to elide the text if it's too big I recommend either \fB''\fR the default or \fB'…'\fR\&.
.RE
.RE
.RE
.RE

Top of Document [#table-of-contents]
.SS left
.IP \(bu 2m
⋄
.RS 2n
.IP \(bu 2m
Left Justifying text\&.
.IP

.RS 4m
.EX
sub left(Str:D $text, Int:D $width is copy, Str:D $fill = ' ',
        :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) = &left\-global\-number\-of\-chars,
                    Str:D :$ref = strip\-ansi($text), Int:D :$max\-width = 0,
                                        Str:D :$ellipsis = '' \-\-> Str) is export


.EE
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fBleft\fR is the same except that except that it puts all the padding on the right of the field\&.
.RE
.RE

Top of Document [#table-of-contents]
.SS right
.IP \(bu 2m
⋄
.RS 2n
.IP \(bu 2m
Right justifying text\&.
.IP

.RS 4m
.EX
sub right(Str:D $text, Int:D $width is copy, Str:D $fill = ' ',
          :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) = &right\-global\-number\-of\-chars,
                    Str:D :$ref = strip\-ansi($text), Int:D :$max\-width = 0,
                                             Str:D :$ellipsis = '' \-\-> Str) is export


.EE
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fBright\fR is again the same except it puts all the padding on the left and the text to the right\&.
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Top of Document [#table-of-contents]
.IP
.SS crop\-field
.RE
.RE
.RS 2n
.IP \(bu 2m
text
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Cropping Text in a field\&.
.IP

.RS 4m
.EX
sub crop\-field(Str:D $text,
               Int:D $w is rw,
               Int:D $width is rw,
               Bool:D $cropped is rw,
               Int:D $max\-width,
               Str:D :$ellipsis = '' \-\-> Str:D) is export {


.EE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBcrop\-field\fR used by \fBcentre\fR, \fBleft\fR and \fBright\fR to crop their input if necessary\&. Copes with ANSI escape codes\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBWhere\fR
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$text\fR is the text to be cropped possibly, wit ANSI escapes embedded\&. 
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$w\fR is used to hold the width of \fB$text\fR is read\-write so will return that value\&.
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$width\fR is the desired width\&. Will be used to return the updated width\&.
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$cropped\fR is used to return the status of whether or not \fB$text\fR was truncated\&.
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$max\-width\fR is the maximum width we are allowing\&.
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$ellipsis\fR is used to supply a eliding \&. Empty string by default\&.
.RE
.RE
.RE
.RE
.RE
Top of Document [#table-of-contents]
.SS Sprintf
.IP \(bu 2m
Sprintf like sprintf only it can deal with ANSI highlighted text\&. And has lots of other options, including the ability to specify a \fB$max\-width\fR using \fBwidth\&.precision\&.max\-width\fR, which can be \fB\&.*\fR, \fB*<num>$\fR, \fB\&.*\fR, or \fB<num>\fR
.IP

.RS 4m
.EX
sub Sprintf(Str:D $format\-str,
           :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) =
                                             &Sprintf\-global\-number\-of\-chars,
                                             Str:D :$ellipsis = '',
                                             *@args \-\-> Str) is export 


.EE
.RE
.RS 2n
.IP \(bu 2m
Where:
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fBformat\-str\fR is is a superset of the \fBsprintf\fR format string, but it has extra features: like the flag \fB[ <char> ]\fR where <char> can be almost anything except \fB[\fR, \fB]\fR \fBcontrol characters\fR, \fBwhite space other than the normal space\fR, and \fBmax\-width\fR after the precision\&.
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
The format string looks like this: 
.IP

.RS 4m
.EX
token format      { <chunks>+ }
token chunks      { [ <chunk> || '%' <format\-spec> ] }
token chunk       { <\-[%]>+ }
token format\-spec { [ <fmt\-esc> || <fmt\-spec> ] }
token fmt\-esc     { [      '%' #`« a literal % »
                        || 'N' #`« a nl i\&.e\&. \n char but does not require interpolation so no double quotes required »
                        || 'T' #`« a tab i\&.e\&. \t char but does not require interpolation so no double quotes required »
                        || 'n' #`« not implemented and will not be, throws an exception if matched »
                        || 't' #`« not implemented and will not be, throws an exception if matched »
                    ]
                  }
token fmt\-spec   { [ <dollar\-directive> '$' ]? <flags>?  <width>? [ '\&.' <precision> [ '\&.' <max\-width> ]? ]? <modifier>? <spec\-char> }



.EE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
Top of Document [#table-of-contents]
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
Where
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBdollar\-directive\fR is a integer >= 1
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBflags\fR is any zero or more of:
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB+\fR put a plus in front of positive values\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB\-\fR left justify, right is the default
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB^\fR centre justify\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB#\fR ensure the leading \fB0\fR for any octal, prefix non\-zero hexadecimal with \fB0x\fR or \fB0X\fR, prefix non\-zero binary with \fB0b\fR or \fB0B\fR
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBv\fR vector flag (used only with d directive)
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB' '\fR pad with spaces\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB0\fR pad with zeros\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB[ <char> ]\fR pad with character char where char matches:
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB<\-[ <cntrl> \s \[ \] ]> || ' '\fR i\&.e\&. anything except control characters, white space (apart from the basic white space (i\&.e\&. \x20 or the one with ord 32)), and \fB[\fR and finally \fB]\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
Top of Document [#table-of-contents]
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBwidth\fR is either an integer or a \fB*\fR or a \fB*\fR followed by an integer >= 1 and a '$'\&.
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBprecision\fR is a \fB\&.\fR followed by either an positive integer or a \fB*\fR or a \fB*\fR followed by an integer >= 1 and a '$'\&.
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBmax\-width\fR is a \fB\&.\fR followed by either an positive integer or a \fB*\fR or a \fB*\fR followed by an integer >= 1 and a '$'\&.
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBmodifier\fR These are not implemented but is one of:
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBhh\fR interpret integer as a type \fBchar\fR or \fBunsigned char\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBh\fR interpret integer as a type \fBshort\fR or \fBunsigned short\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBj\fR interpret integer as a type \fBintmax_t\fR, only with a C99 compiler (unportable)\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBl\fR interpret integer as a type \fBlong\fR or \fBunsigned long\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBll\fR interpret integer as a type \fBlong long\fR, \fBunsigned long long\fR, or \fBquad\fR (typically 64\-bit integers)\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBq\fR interpret integer as a type \fBlong long\fR, \fBunsigned long long\fR, or \fBquad\fR (typically 64\-bit integers)\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBL\fR interpret integer as a type \fBlong long\fR, \fBunsigned long long\fR, or \fBquad\fR (typically 64\-bit integers)\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBt\fR interpret integer as a type \fBptrdiff_t\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBz\fR interpret integer as a type \fBsize_t\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
Top of Document [#table-of-contents]
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBspec\-char\fR or the conversion character is one of:
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBc\fR a character with the given codepoint\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBs\fR a string\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBd\fR a signed integer, in decimal\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBu\fR an unsigned integer, in decimal\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBo\fR an unsigned integer, in octal, with a \fB0o\fR prepended if the \fB#\fR flag is present\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBx\fR an unsigned integer, in hexadecimal, with a \fB0x\fR prepended if the \fB#\fR flag is present\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBe\fR a floating\-point number, in scientific notation\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBf\fR a floating\-point number, in fixed decimal notation\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBg\fR a floating\-point number, in %e or %f notation\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBX\fR like \fBx\fR, but using uppercase letters, with a \fB0X\fR prepended if the \fB#\fR flag is present\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBE\fR like \fBe\fR, but using an uppercase \fBE\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBG\fR like \fBg\fR, but with an uppercase \fBE\fR (if applicable)\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBb\fR an unsigned integer, in binary, with a \fB0b\fR prepended if the \fB#\fR flag is present\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBB\fR an unsigned integer, in binary, with a \fB0B\fR prepended if the \fB#\fR flag is present\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBi\fR a synonym for \fB%d\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBD\fR a synonym for \fB%ld\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBU\fR a synonym for \fB%lu\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBO\fR a synonym for \fB%lo\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBF\fR a synonym for \fB%f\fR\&.
.RE
.RE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
Top of Document [#table-of-contents]
.RE
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB:&number\-of\-chars\fR is an optional named argument which takes a function with a signature \fB:(Int:D, Int:D \-\- Bool:D)\fR> if not specified it will have the value of \fB&Sprintf\-global\-number\-of\-chars\fR which is defined as:
.IP

.RS 4m
.EX
our $Sprintf\-total\-number\-of\-chars is export = 0;
our $Sprintf\-total\-number\-of\-visible\-chars is export = 0;

sub Sprintf\-global\-number\-of\-chars(Int:D $number\-of\-chars, Int:D $number\-of\-visible\-chars \-\-> Bool:D) {
    $Sprintf\-total\-number\-of\-chars         = $number\-of\-chars;
    $Sprintf\-total\-number\-of\-visible\-chars = $number\-of\-visible\-chars;
    return True
}


.EE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
This is exactly the same as the argument by the same name in \fBcentre\fR, \fBleft\fR and \fBright\fR above\&.
.IP
i\&.e\&. 
.IP

.RS 4m
.EX
sub test( \-\-> True) is export {
    \&.\&.\&.
    \&.\&.\&.
    \&.\&.\&.
    my $test\-number\-of\-chars = 0;
    my $test\-number\-of\-visible\-chars = 0;

    sub test\-number\-of\-chars(Int:D $number\-of\-chars, Int:D $number\-of\-visible\-chars \-\-> Bool:D) {
        $test\-number\-of\-chars         = $number\-of\-chars;
        $test\-number\-of\-visible\-chars = $number\-of\-visible\-chars;
        return True
    }

    put Sprintf('%30\&.14\&.14s, %30\&.14\&.13s%N%%%N%^*\&.*s%3$*4$\&.*3$\&.*6$d%N%2$^[&]*3$\&.*4$\&.*6$s%T%1$[*]^100\&.*4$\&.99s',
                                        ${ arg => $highlighted, ref => $text }, $text, 30, 14, $highlighted, 13,
                                                                    :number\-of\-chars(&test\-number\-of\-chars), :ellipsis('…'));
    dd $test\-number\-of\-chars,  $test\-number\-of\-visible\-chars;
    put Sprintf('%30\&.14\&.14s,  testing %30\&.14\&.13s%N%%%N%^*\&.*s%3$*4$\&.*3$\&.*6$d%N%2$^[&]*3$\&.*4$\&.*6$s%T%1$[*]^100\&.*4$\&.99s',
                                $[ $highlighted, $text ], $text, 30, 14, $highlighted, 13, 13,
                                                                    :number\-of\-chars(&test\-number\-of\-chars), :ellipsis('…'));
    dd $test\-number\-of\-chars,  $test\-number\-of\-visible\-chars;
    \&.\&.\&.
    \&.\&.\&.
    \&.\&.\&.
}


.EE
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBNote: This is a closure we should always use a closure if we want to get the number of characters printed\&.\fR 
.RE
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
Top of Document [#table-of-contents]
.RE
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB:$ellipsis\fR this is an optional argument of type \fBStr:D\fR which defaults to \fB''\fR, if set will be used to mark elided text, if the argument is truncated due to exceeding the value of \fBmax\-width\fR (note \fBmax\-width\fR defaults to \fB0\fR which means infinity)\&. The recommended value would be something like \fB…\fR\&.
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB*@args\fR is an arbitrary long list of values each argument can be either a scalar value to be printed or a Hash or an Array
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
If a Hash then it should contain two pairs with keys: \fBarg\fR and \fBref\fR; denoting the actual argument and a reference argument respectively, the ref argument should be the same as \fBarg\fR but with no ANSI formatting etc to mess up the counting\&. As this ruins formatting spacing\&. If not present will be set to \fBstrip\-ansi($arg)\fR, only bother with all this if \fBstrip\-ansi($arg)\fR isn't good enough\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
If a Array then it should contain two values\&. The first being \fBarg\fR and the other being \fBref\fR; everything else is the same as above\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBarg\fR the actual argument\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB@args[$i][]\fR the actual argument\&. Where \fB$i\fR is the current index into the array of args\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB@args[$i][1]\fR the reference argument, as in the \fB:$ref\fR arg of the \fBleft\fR, \fBright\fR and \fBcentre\fR functions which it uses\&. It only makes sense if your talking strings possibly formatted if not present will be set to \fBstrip\-ansi($arg)\fR if $arg is a Str or just $arg otherwise\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
If it's a scalar then it's the argument itself\&. And \fB$ref\fR is \fBstrip\-ansi($arg)\fR if $arg is a string type i\&.e\&. Str or just \fBC\fR$arg>> otherwise\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBref\fR the reference argument, as in the \fB:$ref\fR arg of the \fBleft\fR, \fBright\fR and \fBcentre\fR functions which it uses\&. It only makes sense if your talking strings possibly formatted if not present will be set to \fBstrip\-ansi($arg)\fR if $arg is a Str or just $arg otherwise\&.
.IP
i\&.e\&.
.IP

.RS 4m
.EX
put Sprintf('%30\&.14\&.14s, %30\&.14\&.13s%N%%%N%^*\&.*s%3$*4$\&.*3$\&.*6$d%N%2$^[&]*3$\&.*4$\&.*6$s%T%1$[*]^100\&.*4$\&.99s',
                            ${ arg => $highlighted, ref => $text }, $text, 30, 14, $highlighted, 13,
                                                                        :number\-of\-chars(&test\-number\-of\-chars), :ellipsis('…'));
dd $test\-number\-of\-chars,  $test\-number\-of\-visible\-chars;
put Sprintf('%30\&.14\&.14s,  testing %30\&.14\&.13s%N%%%N%^*\&.*s%3$*4$\&.*3$\&.*6$d%N%2$^[&]*3$\&.*4$\&.*6$s%T%1$[*]^100\&.*4$\&.99s',
                            $[ $highlighted, $text ], $text, 30, 14, $highlighted, 13, 13,
                                                                        :number\-of\-chars(&test\-number\-of\-chars), :ellipsis('…'));
dd $test\-number\-of\-chars,  $test\-number\-of\-visible\-chars;


.EE
.RE
.RE
.RE
.RE
.RE
Top of Document [#table-of-contents]
.SS Printf
.IP \(bu 2m
Same as \fBSprintf\fR but writes it's output to \fB$*OUT\fR or an arbitrary filehandle if you choose\&.
.RS 2n
.IP \(bu 2m
defined as
.IP

.RS 4m
.EX
multi sub Printf(Str:D $format\-str,
        :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) = &Sprintf\-global\-number\-of\-chars,
                                      Str:D :$ellipsis = '', *@args \-\-> True) is export {
    Sprintf($format\-str, :&number\-of\-chars, :$ellipsis, |@args)\&.print;
} #`««« sub Printf(Str:D $format\-str,
         :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) = &Sprintf\-global\-number\-of\-chars,
                                      Str:D :$ellipsis = '', *@args \-\-> True) is export »»»

multi sub Printf(IO::Handle:D $fp, Str:D $format\-str,
         :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) = &Sprintf\-global\-number\-of\-chars,
                                      Str:D :$ellipsis = '', *@args \-\-> True) is export {
    $fp\&.print: Sprintf($format\-str, :&number\-of\-chars, :$ellipsis, |@args);
} #`««« sub Printf(my IO::Handle:D $fp, Str:D $format\-str,
         :&number\-of\-chars:(Int:D, Int:D \-\-> Bool:D) = &Sprintf\-global\-number\-of\-chars,
                                      Str:D :$ellipsis = '', *@args \-\-> True) is export »»»


.EE
.RE
.RE

Top of Document [#table-of-contents]
.SS MultiT

A lot of types but not Any\&.

.RS 4m
.EX
subset MultiT is export of Any where * ~~  Str | Int | Rat | Num | Bool | Array;


.EE
.RE
.SS menu

Display a text based menu\&.

.RS 4m
.EX
sub menu(@candidates is copy, Str:D $message = "",
                              :&row:(Int:D $c, Int:D $p, @a,
                                     Bool:D :$colour = False, Bool:D :$syntax = False,
                                     Str:D :$highlight\-bg\-colour = '',
                                     Str:D :$highlight\-fg\-colour = '',
                                     Str:D :$bg\-colour0 = '',
                                     Str:D :$fg\-colour0 = '', 
                                     Str:D :$bg\-colour1 = '',
                                     Str:D :$fg\-colour1 = '' \-\-> Str:D) = &default\-row, 
                              :&value:(Int:D $c, @a \-\-> MultiT) = &default\-value, 
                              Bool:D :c(:color(:$colour)) is copy = False,
                              Bool:D :s(:$syntax) = False, 
                              Str:D :$highlight\-bg\-colour = t\&.bg\-color(0, 0, 127) ~ t\&.bold, 
                              Str:D :$highlight\-fg\-colour = t\&.bright\-yellow, 
                              Str:D :$bg\-colour0 = t\&.bg\-yellow ~ t\&.bold, 
                              Str:D :$fg\-colour0 = t\&.bright\-blue, 
                              Str:D :$bg\-colour1 = t\&.bg\-color(0, 127, 0) ~ t\&.bold, 
                              Str:D :$fg\-colour1 = t\&.bright\-blue,  
                              Str:D :$bg\-prompt = t\&.bg\-green ~ t\&.bold, 
                              Str:D :$fg\-prompt = t\&.bright\-blue, 
                              Bool:D :$wrap\-around = False \-\-> MultiT) is export 


.EE
.RE
.IP \(bu 2m
Where:
.RS 2n
.IP \(bu 2m
\fB@candidates\fR is an array of hashes to make up the rows of the menu\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$message\fR is a message to be displayed at the top of the ascii text form of things (i\&.e\&. no colourising)\&.
.RE
.RS 2n
.IP \(bu 2m
\fB&row\fR is is a callback to deal with the rows of the menu\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Where
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$c\fR is the current row count\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$p\fR is the current position in the @candidates array\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB@a\fR is the array @candidates itself\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$highlight\-bg\-colour\fR is the background colour of the current row (i\&.e\&. $c == $p)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$highlight\-fg\-colour\fR is the foreground colour of the current row (i\&.e\&. $c == $p)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$bg\-colour0\fR is the background colour of the row (i\&.e\&. $c %% 2)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$fg\-colour0\fR is the foreground colour of the row (i\&.e\&. $c %% 2)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$bg\-colour1\fR is the background colour of the row (i\&.e\&. $c % 2 != 0 or not $c %% 2)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$fg\-colour1\fR is the foreground colour of the row (i\&.e\&. $c % 2 != 0)\&.
.RE
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB&value\fR is a callback to get the return value for the function\&.
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$c\fR is the row selected\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$c\fR is the array @candidates\&.
.RE
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB:c(:color(:$colour))\fR defines a boolean flag to tell whether to use colours or not\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
you can use \fB:c\fR, \fB:color\fR or \fB:colour\fR for this they are all exactly the same\&.
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB:s(:$syntax)\fR same as \fB$colour\fR except it could result in some sort of syntax highlighting\&. 
.RE
.RS 2n
.IP \(bu 2m
\fB$highlight\-bg\-colour\fR the background colour to use to highlight the current line\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$highlight\-fg\-colour\fR the foreground colour to use to highlight the current line\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$bg\-colour0\fR the background colour to use if the line count is divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fg\-colour0\fR the foreground colour to use if the line count is divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$bg\-colour1\fR the background colour to use if the line count is not divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fg\-colour1\fR the foreground colour to use if the line count is not divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$bg\-prompt\fR the background colour to use on the prompt line below the selection area\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fg\-prompt\fR the foreground colour to use on the prompt line below the selection area\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$wrap\-around\fR if true then the selection area wraps around, (i\&.e going past the end wraps around, instead of refusing to go there)\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$highlight\-bg\-colour\fR to \fB$wrap\-around\fR are all just used for the dropdown case (i\&.e\&. \fB$colour\fR or \fB$syntax\fR are True)
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$syntax\fR is no different from \fB$colour\fR unless the user defines it using the \fB:&row\fR parameter\&.
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
calls dropdown [#dropdown] to do the colour work\&.
.RE
.RE
.RE

Top of Document [#table-of-contents]
.SS input\-menu(…)

.RS 4m
.EX
sub input\-menu(@candidates is copy, Str:D $message = "",
                              :&row:(Int:D $c, Int:D $p, @a,
                                     Bool:D :$colour = False, Bool:D :$syntax = False,
                                     Str:D :$highlight\-bg\-colour = '', Str:D :$highlight\-fg\-colour = '',
                                     Str:D :$bg\-colour0 = '', Str:D :$fg\-colour0 = '', 
                                     Str:D :$bg\-colour1 = '', Str:D :$fg\-colour1 = '' \-\-> Str:D) = &default\-row\-input\-menu, 
                              :&value:(Int:D $c, @a \-\-> MultiT) = &default\-value, 
                              :&elt\-prompt:(Int:D $c, @a,
                                     Bool:D :$colour = False, Bool:D :$syntax = False,
                                     Str:D :$bg\-prompt = '', Str:D :$fg\-prompt = '' \-\-> Str:D)  = &default\-prompt,
                              :&edit:(Int:D $c, @a is copy, Str:D $e \-\-> Bool:D) = &default\-edit, 
                              Bool:D :c(:color(:$colour)) is copy = False,
                              Bool:D :s(:$syntax) = False, 
                              Str:D :$highlight\-bg\-colour = t\&.bg\-color(0, 0, 127) ~ t\&.bold, 
                              Str:D :$highlight\-fg\-colour = t\&.bright\-yellow, 
                              Str:D :$bg\-colour0 = t\&.bg\-yellow ~ t\&.bold, 
                              Str:D :$fg\-colour0 = t\&.bright\-blue, 
                              Str:D :$bg\-colour1 = t\&.bg\-color(0, 127, 0) ~ t\&.bold, 
                              Str:D :$fg\-colour1 = t\&.bright\-blue,  
                              Str:D :$bg\-prompt = t\&.bg\-green ~ t\&.bold, 
                              Str:D :$fg\-prompt = t\&.bright\-blue, 
                              Bool:D :$wrap\-around = False \-\-> MultiT) is export 


.EE
.RE
.IP \(bu 2m
Where:
.RS 2n
.IP \(bu 2m
\fB@candidates\fR is an array of hashes to make up the rows of the menu\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$message\fR is a message to be displayed at the top of the ascii text form of things (i\&.e\&. no colourising)\&.
.RE
.RS 2n
.IP \(bu 2m
\fB&row\fR is is a callback to deal with the rows of the menu\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Where
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$c\fR is the current row count\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$p\fR is the current position in the @candidates array\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB@a\fR is the array @candidates itself\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$highlight\-bg\-colour\fR is the background colour of the current row (i\&.e\&. $c == $p)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$highlight\-fg\-colour\fR is the foreground colour of the current row (i\&.e\&. $c == $p)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$bg\-colour0\fR is the background colour of the row (i\&.e\&. $c %% 2)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$fg\-colour0\fR is the foreground colour of the row (i\&.e\&. $c %% 2)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$bg\-colour1\fR is the background colour of the row (i\&.e\&. $c % 2 != 0 or not $c %% 2)\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$fg\-colour1\fR is the foreground colour of the row (i\&.e\&. $c % 2 != 0)\&.
.RE
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB&value\fR is a callback to get the return value for the function\&.
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$c\fR is the row selected\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$c\fR is the array @candidates\&.
.RE
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB&elt\-prompt:(Int:D $c, @a, Bool:D :$colour = False, Bool:D :$syntax = False, Str:D :$bg\-prompt = '', Str:D :$fg\-prompt = '' \-\-> Str:D) = &default\-prompt\fR 
.IP
The callback called by the function to get the prompts to let the user edit the value of the row\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$c\fR is the entry choosen by the user\&.
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB@a\fR is the candidates array\&.
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB:c(:color(:$colour))\fR defines a boolean flag to tell whether to use colours or not\&.
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
you can use \fB:c\fR, \fB:color\fR or \fB:colour\fR for this they are all exactly the same\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB:s(:$syntax)\fR same as \fB$colour\fR except it could result in some sort of syntax highlighting\&. 
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$bg\-prompt\fR the background colour to use on the prompt line below the selection area\&.
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$fg\-prompt\fR the foreground colour to use on the prompt line below the selection area\&.
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB&edit:(Int:D $c, @a is copy, Str:D $e \-\-> Bool:D) = &default\-edit\fR
.IP
The callback called by the function to set the new value of the row\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$c\fR is the entry choosen by the user\&.
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB@a\fR is the candidates array\&.
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB:c(:color(:$colour))\fR defines a boolean flag to tell whether to use colours or not\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
you can use \fB:c\fR, \fB:color\fR or \fB:colour\fR for this they are all exactly the same\&.
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB:s(:$syntax)\fR same as \fB$colour\fR except it could result in some sort of syntax highlighting\&. 
.RE
.RS 2n
.IP \(bu 2m
\fB$highlight\-bg\-colour\fR the background colour to use to highlight the current line\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$highlight\-fg\-colour\fR the foreground colour to use to highlight the current line\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$bg\-colour0\fR the background colour to use if the line count is divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fg\-colour0\fR the foreground colour to use if the line count is divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$bg\-colour1\fR the background colour to use if the line count is not divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fg\-colour1\fR the foreground colour to use if the line count is not divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$bg\-prompt\fR the background colour to use on the prompt line below the selection area\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fg\-prompt\fR the foreground colour to use on the prompt line below the selection area\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$wrap\-around\fR if true then the selection area wraps around, (i\&.e going past the end wraps around, instead of refusing to go there)\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$highlight\-bg\-colour\fR to \fB$wrap\-around\fR are all just used for the dropdown case (i\&.e\&. \fB$colour\fR or \fB$syntax\fR are True)
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
\fB$syntax\fR is no different from \fB$colour\fR unless the user defines it using the \fB:&row\fR parameter\&.
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
calls dropdown [#dropdown] to do the colour work\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
\fBNB: the colours stuff is not yet implemented\fR
.RE
.RE
.RE

Top of Document [#table-of-contents]
.SS dropdown(…)

A text based dropdown/list or menu with ANSI colours\&.

.RS 4m
.EX
sub dropdown(MultiT:D $id, Int:D $window\-height is copy, Str:D $id\-name,
                        &setup\-option\-str:(Int:D $c, Int:D $p, @a \-\-> Str:D),
                        &find\-pos:(MultiT $r, Int:D $p, @a \-\-> Int:D),
                        &get\-result:(MultiT:D $res, Int:D $p, Int:D $l, @a \-\-> MultiT:D),
                        @array,
                        Str:D :$highlight\-bg\-colour = t\&.bg\-color(0, 0, 127) ~ t\&.bold, 
                        Str:D :$highlight\-fg\-colour = t\&.bright\-yellow, 
                        Str:D :$bg\-colour0 = t\&.bg\-yellow ~ t\&.bold, 
                        Str:D :$fg\-colour0 = t\&.bright\-blue, 
                        Str:D :$bg\-colour1 = t\&.bg\-color(0, 127, 0) ~ t\&.bold, 
                        Str:D :$fg\-colour1 = t\&.bright\-blue,  
                        Str:D :$bg\-prompt = t\&.bg\-green ~ t\&.bold, 
                        Str:D :$fg\-prompt = t\&.bright\-blue, 
                        Bool:D :$wrap\-around = False \-\-> MultiT) is export  


.EE
.RE
.IP \(bu 2m
Where
.RS 2n
.IP \(bu 2m
\fB$id\fR is the starting value of our position in the array/choices\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$window\-height\fR is the number of rows of characters to display at a time\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$id\-name\fR is the name of the parameter we are scrolling\&.
.RE
.RS 2n
.IP \(bu 2m
\fB&setup\-option\-str\fR is a function that returns the current row\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Where:
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB$c\fR will be the count of the row we are drawing\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB$p\fR will be the position in the array we are at\&. 
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB@a\fR will be the \fB@array\fR supplied to \fBdropdown(…)\fR 
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the use of a function for this means you can compute a much more complex field\&.
.RE
.RE
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB&find\-pos\fR is a function that finds the start position in the \fBdropdown\fR\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Where:
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB$r\fR is the value in the array \fB@array\fR to look for\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB$p\fR is the best approximation of where it might be if you are using it in a loop or something it could be where it last was\&. 
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB@a\fR the argument \fB@array\fR that was passed to \fBdropdown\fR\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
you can name these argument anything you like in you function, and because of the computed nature of this function and the other two you have great flexibility\&.
.RE
.RE
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB&get\-result\fR is a function to work out the value selected\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Where:
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB$res\fR is the default value to return\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB$p\fR is the current position in the array \fB@array\fR supplied to \fBdropdown\fR\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB$l\fR is the length of the array \fB@array\fR\&.
.RE
.RE
.RE
.RS 2n
.RS 2n
.RS 2n
.IP \(bu 2m
the arg \fB@a\fR is the array \fB@array\fR that was supplied to \fBdropdown\fR\&.
.RE
.RE
.RE
.RS 2n
.IP \(bu 2m
\fB@array\fR the array of rows to display\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$highlight\-bg\-colour\fR the background colour to use to highlight the current line\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$highlight\-fg\-colour\fR the foreground colour to use to highlight the current line\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$bg\-colour0\fR the background colour to use if the line count is divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fg\-colour0\fR the foreground colour to use if the line count is divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$bg\-colour1\fR the background colour to use if the line count is not divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fg\-colour1\fR the foreground colour to use if the line count is not divisible by 2\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$bg\-prompt\fR the background colour to use on the prompt line below the selection area\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fg\-prompt\fR the foreground colour to use on the prompt line below the selection area\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$wrap\-around\fR if true then the selection area wraps around, (i\&.e going past the end wraps around, instead of refusing to go there)\&.
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Because we use a function we can compute much more complex results; depending on what we have in \fB@array\fR\&. The result can be any of Str, Int, Rat or Num see MultiT [#multit]\&.
.RE
.RE

Here is an example of use\&.

Top of Document [#table-of-contents]

.RS 4m
.EX
my &setup\-option\-str = sub (Int:D $cnt, Int:D $p, @array \-\-> Str:D ) {
    my Str $name;
    my Str $cc;
    my Str $flag;
    my Str $prefix;
    if $cnt < 0 {
        $name   = "No country selected yet\&.";
        $cc     = "";
        $flag   = "";
        $prefix = "you must choose one";
    } else {
        my %row = @array[$cnt];
        $name   = %row«_name»;
        $cc     = %row«cc»;
        try {
            CATCH {
                default {
                    my $Name = $name;
                    $Name ~~ s:g/ <wb> 'and' <wb> /\&/;
                    try {
                        CATCH {
                            default { $flag = uniparse 'PENGUIN'}
                        }
                        $flag = uniparse $Name;
                    }
                }
            }
            $flag   = uniparse $name;
        }
        $prefix = %row«prefix»;
    }
    return "$flag $name: $cc ($prefix)"
};
my &find\-pos = sub (MultiT $result, Int:D $pos, @array \-\-> Int:D) {
    for @array\&.kv \-> $idx, %r {
        if %r{$id\-name} == $result {
            $pos = $idx;
            last; # found so don't waste resources #
        }
    }
    return $pos;
}
my &get\-result = sub (MultiT:D $result, Int:D $pos, Int:D $length, @array \-\-> MultiT:D ) {
    my $res = $result;
    if $pos ~~ 0\&.\&.^$length {
      my %row = |%(@array[$pos]);
      $res = %row«id» if %row«id»:exists;
    }
    return $res
};
my Int:D $cc\-id        = dropdown($cc_id, 20, 'id',
                                    &setup\-option\-str, &find\-pos, &get\-result, @_country);
while !valid\-country\-cc\-id($cc\-id, %countries) {
    $cc\-id             = dropdown($cc\-id, 20, 'id',
                                    &setup\-option\-str, &find\-pos, &get\-result, @_country);
}


.EE
.RE
.P
Or using a much simpler array\&. \fBNB: from menu\fR

Top of Document [#table-of-contents]

.RS 4m
.EX
my &setup\-option\-str = sub (Int:D $cnt, Int:D $pos, @array \-\-> Str:D ) {
    return @array[$cnt];
};
my &get\-result = sub (MultiT:D $result, Int:D $pos, Int:D $length, @array \-\-> MultiT:D ) {
    my $res = $result;
    if $pos ~~ 0\&.\&.^$length {
      $res = @array[$pos];
    }
    return $res
};
my &find\-pos = sub (MultiT $result, Int:D $pos, @array \-\-> Int:D) {
    for @array\&.kv \-> $idx, $r {
        if $r eq $result {
            $pos = $idx;
            last; # found so don't waste resources #
        }
    }
    return $pos;
}
my Str:D $result = dropdown(@candidates[@candidates\&.elems \- 1], 40, 'backup',
                                    &setup\-option\-str, &find\-pos, &get\-result, @candidates);


.EE
.RE
.P
Top of Document [#table-of-contents]
.SS lead\-dots(…)

Returns \fB$text\fR in a field of \fB$width\fR with a line of dots preceding it\&. Sort of like \fBleft\fR with \fB$fill\fR defaulting to \fB\&.\fR but with a single space between the text and the padding\&.

.RS 4m
.EX
sub lead\-dots(Str:D $text, Int:D $width is copy, Str:D $fill = '\&.' \-\-> Str) is export


.EE
.RE
.IP \(bu 2m
Where:
.RS 2n
.IP \(bu 2m
\fB$text\fR the text to be preceded by the dots\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$width\fR the width of the total field\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fill\fR the fill char or string\&.
.RE

Top of Document [#table-of-contents]
.SS trailing\-dots(…)

Returns \fB$text\fR in a field of \fB$width\fR with a line of dots trailing after it\&. Sort of like \fBright\fR with \fB$fill\fR defaulting to \fB\&.\fR but with a single space between the text and the padding\&.

.RS 4m
.EX
sub trailing\-dots(Str:D $text, Int:D $width is copy, Str:D $fill = '\&.' \-\-> Str) is export


.EE
.RE
.IP \(bu 2m
Where:
.RS 2n
.IP \(bu 2m
\fB$text\fR the text to be trailed by the dots\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$width\fR the width of the total field\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fill\fR the fill char or string\&.
.RE

Top of Document [#table-of-contents]
.SS dots(…)

Returns \fB$text\fR in a field of \fB$width\fR with a line of dots preceding it\&. Sort of like \fBleft\fR with \fB$fill\fR defaulting to \fB\&.\fR\&.

.RS 4m
.EX
sub dots(Str:D $text, Int:D $width is copy, Str:D $fill = '\&.' \-\-> Str) is export


.EE
.RE
.IP \(bu 2m
Where:
.RS 2n
.IP \(bu 2m
\fB$text\fR the text to be preceded by the dots\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$width\fR the width of the total field\&.
.RE
.RS 2n
.IP \(bu 2m
\fB$fill\fR the fill char or string\&.
.RE

Top of Document [#table-of-contents]
